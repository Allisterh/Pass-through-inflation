---
Title: Estimación de los Umbrales
output:
  pdf_document: default
  html_document: default
---

```{r cargando librerias, echo=FALSE, include=FALSE}

library(readxl)
library(tidyverse)
library(NTS)
library(knitr)
library(kableExtra)
library(devtools)
```

```{r Cargando datos, echo=FALSE}

datos <- read_excel("D:/Documentos/PES/Para la tesis/Tesis/Pass through/Datos/Datos.xlsx", sheet = "Datos consolidados")

```

# Estimación de los umbrales de inflacón para la estimación del efecto *Pass through*

Para la estimacióno de los umbrales se seguirá un proceso secuencial de busqueda en el que se estimará un modelo inicial para todos los umbrales posibles[^1] siendo el modelo que ajuste con la menor suma de residos al cuadrado el que se tomará de referencia para determinar el primer umbra. Una vez definido el primer umbral se estima un núevo modelo siguiendo el procedimiento hasta el número de umbrales deseados.  

El primer modelo a estimar es:

\[\Delta^{12}P_t =\beta_0 + \beta_1\Delta^{12}P_{t-1} + I_t\alpha_a e_t^{12} + 
(1-I_t)\alpha_b e_t^{12} + \beta_2\Delta^{12}P_{Et}^{12} + \beta_3y_t^{brecha}\]

\[\Delta^{12}P_t =\beta_0 + \beta_1\Delta^{12}P_{t-1} + \beta_2e_t^{12} + 
\delta_ae_t^{12}*(\Delta^{12}P_{t-1}<\tau) + \beta_3\Delta^{12}P_{Et}^{12} + \beta_4y_t^{brecha}\]

donde:

$\Delta^{12}P_t$ Variación relativa anualizada del Índice de Precios al Consumidor

$\beta_0$ Componente autónomo de la tas de inflación

$e_t^{12}$ Depreciación anualizada del tipo de cambio

$\Delta^{12}P_{Et}^{12}$ Variación relativa anualidad del Índice de Precios al Consumidor de Estados Unidos

$y_t^{brecha}$ Brecha relativa del producto respecto del potencial

$\tau$ Detona el valor del umbral para el régimen de inflación

$\Delta^{12}P_{t-1}<\tau$ Variable dicotómica que es 1 en régimen de inflación alta y 0 en régimen de iflación baja

En donde es claro que el uso de la dicotómica separa los regímenes de inflación. 

```{r modelos}

# Construcción de data frame a utilizar

attach(datos)

datos_modelo <- data.frame(inf_gt_anualizada, inf_eua_anualizada, 
                           brecha = var_brecha, deprec_anualizada)

detach(datos)

# construcción de la infalción inercial (inflación del periodo anterior)

inercial <- c(NA, datos_modelo[c(1:256),1])

datos_modelo <- cbind(datos_modelo, inercial)
datos_modelo <- select(.data = datos_modelo, inf_gt_anualizada, inercial, 
                       inf_eua_anualizada, brecha, deprec_anualizada)
datos_modelo <- datos_modelo[c(2:257),]

# Reordenando índices
row.names(datos_modelo) <- c(1:256)

```

\begin{center}
Datos a utilizar
\end{center}

```{r Tabla de datos, echo=FALSE}

# con linebrake dentro del agumento col.names podemos separar 
# los nombres según lo especifiquemos

kable(head(datos_modelo), digits = 5,
      col.names = linebreak(c("inflación anualizada\nGuatemala", 
                    "inflación inercial\nGuatemala", 
                    "inflación anualizada\nEstados Unidos",
                    "brecha del producto", 
                    "Depreciación anualizada\nQuetzales x USD 1"), 
                    align = "c"), 
      align = "c", escape = FALSE)

```

## Estimación de los distintos modelos

Como se especificó la varialbe dicotómica $I_t$ será 0 si el régimen de inflación es bajo o 1 si el régimen de inflación es alto, todo para cada uno de los umbrales posibles.

```{r estimación de modelos}
# Creación de todos los posibles umbrales
# Número de umbrales fuera por debajo o arriba de la muestra

umbrales_fuera <- 257 - round(257 - 257*0.3, digits = 0)

# posibles umbrales del modelo

posibles1 <- sort(inercial)
posibles1 <- posibles1[round((umbrales_fuera/2 + 2), 0):
                       (length(inercial)-1-round(umbrales_fuera/2,0))] 


# Lista de modelos

nombre_modelos <- c()
modelos <- list()
bases <- list()

# Estimación de los modelos por cada umbral

for (i in c(1:length(posibles1))) {
  
  nombre_modelos[i] <- c(sprintf("modelo_%s_%s", i, posibles1[i]))
  
  m <- mutate(datos_modelo, 
                     d = ifelse(inercial<posibles1[i], yes = 1, no = 0))
  
  bases[[i]] <- m
  
  modelo <- lm(bases[[i]],
                      formula = inf_gt_anualizada ~ 1 +
                        deprec_anualizada*d + inercial +
                        inf_eua_anualizada + brecha - d)
  
  modelos[[i]] <- modelo
  
}

names(modelos) <- nombre_modelos
```

Luego de la estimación de los modelos se procede al cálculo de la suma de residuos al cuadrado (ssr) de cada modelo.

```{r calculo SSR}

ssr <- c()

for (i in c(1:length(posibles1))) {
  
  ssr[i] <- sum(modelos[[i]]$residuals^2)
  
}
```

## Identificación del primer umbral

Una vez determinada la ssr se procede a la identificacióno del primer umbral escogiendo el modelo con la menor ssr.
```{r identificación tau 1}

names(modelos[ssr==min(ssr)])
# Como se observa son los modelos 11 y 12 con inflación de 0.01692999 anual
# los modelo con menor ssr y por lo tanto este es el primer umbral.

# Forma grafica de identificacion del umbral

ggplot() + 
  geom_line(aes(y = ssr, x = posibles1), colour = "#2A5783", size = 1) +
  geom_vline(xintercept = posibles1[ssr == min(ssr)], 
             linetype = 3, size = 1.3) +
  labs(title = "Estimación de umbrales \nPrimera especificación del modelo", 
       y = "ssr", x = "Umbrales posibles") +
  geom_text(aes(y = 0.6658, x = 0.032,
                label = "Primer Umbral \n0.0169")) +
  theme_classic(base_size = 15)
  
```

# Estimación del nuevo umbral

Una vez determinado el primer primer umbral este se toma como dado en la primera especificación del modelo y se estima una nueva especificación con el conjunto de umbrales posibles restantes.

La nueva especificación es:

\[\Delta^{12}P_t = \beta_0 + \beta_1\Delta^{12}P_{t-1} + \beta_2e^{12}_t  
+ \delta_ae^{12}_t*(\Delta^{12}P_{t-1}\leq0.016929)+ 
\delta_be^{12}_t*(0.016929<\Delta^{12}P_{t-1}\leq\tau_2)+
\beta_3\Delta^{12}P_{Et}^{12} + \beta_4y_t^{brecha}\]

En este caso $\tau_2$ representa el segundo umbral a determinar.

```{r Separación de la base de datos para estiamr el segundo umbral}

# Eliminación del primer umbral del conjunto del umbrales posibles

posibles2 <- posibles1[ssr!= min(ssr)]

# Como ya se eliminó el primer umbral del conjunto posible de umbrales, lo que
# resta es estimar los modelos nuevamente y utilizar la regla de decision.

# Para comenzar se utilzara la base de datos del modelo 11 que es modelo que 
# contiene la dicotonica con el primer umbral

base_umbral1 <- bases[ssr==min(ssr)]

# Comprobación entre las bases de datos

base_umbral1[[1]]$d - base_umbral1[[2]]$d

base_umbral1 <- bases[[1]]
```

```{r Estimación de la segunda especificación del modelo}

nombres_modelos2 <- c()
bases2 <- list()
modelos2 <- list()

for (i in c(1:length(posibles2))) {
  
  nombres_modelos2[i] <- sprintf("modelo_%s_0.01692996_%s", i ,posibles2[i])
  
  n <- base_umbral1 %>% mutate(d2 = ifelse(inercial >= 0.0169299655858599 &
                                             inercial < posibles2[i],
                                           yes = 1, no = 0))
  
  bases2[[i]] <- n
  
  modelo2 <- lm(n, formula = inf_gt_anualizada ~ 1 +
                  deprec_anualizada*d + deprec_anualizada*d2 + inercial + 
                  inf_eua_anualizada + brecha - d - d2)
  
  modelos2[[i]] <- modelo2
  
}

names(modelos2) <- nombres_modelos2

```

```{r Calculo de la ssr}

ssr2 <- c()

for (i in c(1:length(posibles2))) {
  
  ssr2[i] <- sum(modelos2[[i]]$residuals^2)
  
}
```

```{r identificacion del umbral}

names(modelos2[ssr2 == min(ssr2)])

# Forma grafica de identificacion del umbral

ggplot() + 
  geom_line(aes(y = ssr2, x = posibles2), colour = "#2A5783", size = 1) +
  geom_vline(xintercept = posibles2[ssr2 == min(ssr2)], 
             linetype = 3, size = 1.3) +
  labs(title = "Estimación de umbrales \nSegunda especificación del modelo", 
       y = "ssr", x = "Umbrales posibles") +
  geom_text(aes(y = 0.6591, x = 0.048,
                label = "Segundo Umbral \n0.0341")) +
  theme_classic(base_size = 15)
  

```

# Resultados del modelo TAR

```{r resultados}

names(modelos2[ssr2 == min(ssr2)])
modelo_ganador <- modelos2[ssr2 == min(ssr2)]
modelo_ganador <- modelo_ganador[[1]]

summary(modelo_ganador)
ssr_ganador <- sum(modelo_ganador$residuals^2)
ssr_ganador
```

```{r}

hist(modelo_ganador$residuals)

tseries::jarque.bera.test(modelo_ganador$residuals)
qqnorm(modelo_ganador$residuals)
qqline(modelo_ganador$residuals)
plot(modelo_ganador$residuals)

acf(modelo_ganador$residuals)


```





[^1]: Chang(1993) recomienda usar el 70% de las observaciones cenetrales